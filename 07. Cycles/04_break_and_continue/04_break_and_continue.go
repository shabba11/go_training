package main

import "fmt"

func main() {
	var numbers = [10]int{1, -2, 3, -4, 5, -6, -7, 8, -9, 10}
	var sum = 0

	for _, value := range numbers {
		if value < 0 {
			continue // переходим к следующей итерации
		}
		sum += value
	}
	fmt.Println("Sum:", sum) // Sum: 27

	//_____________________________________________//

	var numbersSecond = [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	var sumSecond = 0

	for _, value := range numbersSecond {
		if value > 4 {
			break // если число больше 4 выходим из цикла
		}
		sumSecond += value
	}
	fmt.Println("Sum:", sumSecond) // Sum: 10

	// Оператор break нередко применяется для выхода из вложенных циклов.
	// Для этого оператору передается метка - на нее проецируется цикл, из которого надо выйти

	// метка для перехода к внешнему циклу
OuterLoop:
	for i := 1; i <= 3; i++ {
		for j := 1; j <= 3; j++ {

			fmt.Printf("i = %d, j = %d\n", i, j)

			if i == 2 && j == 2 {

				fmt.Println("Выход из внешнего цикла...")

				break OuterLoop // выходим из внешнего цикла
			}
		}
	}

	fmt.Println("Цикл завершен...")

	// В данном случае у нас два цикла - внешний цикл по i и вложенный по j.
	// Внешний цикл предваряется меткой OuterLoop.
	// Во вложенном цикле, если переменные i и j одновременно равны 2, то выходим из цикла.
	// Однако если бы мы, просто использовали оператор break без метки,
	// то произошел бы выход только из вложенного цикла к следующей итерации внешнего цикла.
	// Однако мы передаем оператору break метку OuterLoop
	// Метка OuterLoop проецируется на внешний цикл, поэтому при выполнении этого оператора break произойдет выход из внешнего цикла

}
